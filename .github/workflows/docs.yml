name: Deploy Documentation

on:
  push:
    branches: [ main ]
    paths:
      - 'docs/**'
      - 'README.md'
      - '.github/workflows/docs.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'docs/**'
      - 'README.md'
  # Allow manual triggering
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1'
          bundler-cache: true
          working-directory: ./docs

      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v4

      - name: Create Gemfile for docs
        run: |
          cd docs
          cat > Gemfile << EOF
          source "https://rubygems.org"
          
          gem "jekyll", "~> 4.3"
          gem "minima", "~> 2.5"
          gem "jekyll-feed", "~> 0.12"
          gem "jekyll-sitemap", "~> 1.4"
          gem "jekyll-seo-tag", "~> 2.8"
          
          # Windows and JRuby does not include zoneinfo files, so bundle the tzinfo-data gem
          # and associated library.
          platforms :mingw, :x64_mingw, :mswin, :jruby do
            gem "tzinfo", "~> 1.2"
            gem "tzinfo-data"
          end
          
          # Performance-booster for watching directories on Windows
          gem "wdm", "~> 0.1.1", :platforms => [:mingw, :x64_mingw, :mswin]
          
          # Lock `http_parser.rb` gem to `v0.6.x` on JRuby builds since newer versions of the gem
          # do not have a Java counterpart.
          gem "http_parser.rb", "~> 0.6.0", :platforms => [:jruby]
          EOF

      - name: Install dependencies
        run: |
          cd docs
          bundle install

      - name: Build with Jekyll
        run: |
          cd docs
          bundle exec jekyll build --baseurl "${{ steps.pages.outputs.base_path }}"
        env:
          JEKYLL_ENV: production

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./docs/_site

  # Deployment job
  deploy:
    if: github.ref == 'refs/heads/main'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  # Link checker job
  check-links:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: github-pages
          path: ./docs/_site

      - name: Extract artifact
        run: |
          cd docs/_site
          tar -xf artifact.tar

      - name: Check internal links
        uses: lycheeverse/lychee-action@v1
        with:
          args: --verbose --no-progress --exclude-all-private 'docs/_site/**/*.html'
          fail: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Documentation quality check
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check documentation structure
        run: |
          # Check required documentation files exist
          required_files=(
            "docs/index.md"
            "docs/installation.md"
            "docs/quickstart.md"
            "docs/configuration.md"
            "docs/architecture.md"
            "docs/api/index.md"
            "docs/_config.yml"
          )
          
          missing_files=()
          for file in "${required_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              missing_files+=("$file")
            fi
          done
          
          if [[ ${#missing_files[@]} -gt 0 ]]; then
            echo "Missing required documentation files:"
            printf '%s\n' "${missing_files[@]}"
            exit 1
          fi
          
          echo "All required documentation files present ✓"

      - name: Check documentation formatting
        run: |
          # Check for basic markdown formatting issues
          find docs -name "*.md" -exec grep -l "^#[^#]" {} \; | while read -r file; do
            # Check if file has proper heading structure
            if ! grep -q "^# " "$file"; then
              echo "Warning: $file missing main heading"
            fi
          done
          
          # Check for relative links
          find docs -name "*.md" -exec grep -l "](\.\./" {} \; | while read -r file; do
            echo "Info: $file contains relative links - verify they work in GitHub Pages"
          done

      - name: Validate YAML frontmatter
        run: |
          python3 -c "
          import yaml
          import sys
          import os
          
          def check_yaml_frontmatter(file_path):
              with open(file_path, 'r') as f:
                  content = f.read()
              
              if content.startswith('---'):
                  try:
                      end = content.find('---', 3)
                      if end != -1:
                          yaml_content = content[3:end]
                          yaml.safe_load(yaml_content)
                          print(f'✓ {file_path}: Valid YAML frontmatter')
                      else:
                          print(f'⚠ {file_path}: Incomplete YAML frontmatter')
                  except yaml.YAMLError as e:
                      print(f'✗ {file_path}: Invalid YAML frontmatter - {e}')
                      sys.exit(1)
              else:
                  print(f'- {file_path}: No YAML frontmatter')
          
          # Check all markdown files
          for root, dirs, files in os.walk('docs'):
              for file in files:
                  if file.endswith('.md'):
                      file_path = os.path.join(root, file)
                      check_yaml_frontmatter(file_path)
          "

      - name: Check for broken internal references
        run: |
          # Find markdown files with internal links and verify targets exist
          find docs -name "*.md" -exec grep -l "\[.*\](.*\.md)" {} \; | while read -r file; do
            echo "Checking internal links in $file"
            grep -o "\[.*\](.*\.md[^)]*)" "$file" | while read -r link; do
              target=$(echo "$link" | sed 's/.*](\([^)]*\)).*/\1/' | sed 's/#.*//')
              if [[ "$target" =~ ^[^/] ]]; then
                # Relative link - resolve relative to current file
                dir=$(dirname "$file")
                full_target="$dir/$target"
              else
                # Absolute link from docs root
                full_target="docs/$target"
              fi
              
              if [[ ! -f "$full_target" ]]; then
                echo "Warning: $file links to non-existent file: $target"
              fi
            done
          done